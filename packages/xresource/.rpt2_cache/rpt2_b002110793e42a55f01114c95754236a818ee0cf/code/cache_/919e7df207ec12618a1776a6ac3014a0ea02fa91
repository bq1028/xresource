{"code":"import { BehaviorSubject } from 'rxjs';\r\nconst mapToObject = (map) => Array.from(map.entries()).reduce((obj, [key, val]) => (Object.assign({}, obj, { [key]: val })), {});\r\nconst errorsFromMap = (map) => {\r\n    const errors = Array.from(map.entries()).reduce((obj, [key, val]) => {\r\n        if (val instanceof Error)\r\n            return Object.assign({}, obj, { [key]: val });\r\n        return obj;\r\n    }, {});\r\n    return Object.keys(errors).length > 0 ? errors : null;\r\n};\r\nconst applyModifiers = (modifiers, ctx, result) => Array.isArray(modifiers)\r\n    ? modifiers.reduce((obj, modifier) => modifier(obj, ctx), result)\r\n    : result;\r\nfunction reduceEffects(effects, factory) {\r\n    return Object.keys(effects).reduce((obj, key) => {\r\n        const effect = effects[key];\r\n        return Object.assign({}, obj, { [key]: factory(effect) });\r\n    }, {});\r\n}\r\nfunction createInstance({ mutations, data: dataDescriptor, context: initialContext, effects: defaultEffects = {}, }) {\r\n    const ctxSubject = new BehaviorSubject(initialContext || {});\r\n    const dataSubject = new BehaviorSubject({\r\n        loading: false,\r\n        errors: null,\r\n    });\r\n    const context$ = ctxSubject.asObservable();\r\n    const data$ = dataSubject.asObservable();\r\n    const effects = reduceEffects(defaultEffects, effect => (...args) => effect(resource, ...args));\r\n    const resource = {\r\n        effects,\r\n        context$,\r\n        data$,\r\n        getContext: () => ctxSubject.value,\r\n        getData: () => dataSubject.value,\r\n        async update() {\r\n            const ctxValue = ctxSubject.value;\r\n            const map = new Map(Object.entries(dataDescriptor));\r\n            const updateDataSubject = (val) => dataSubject.next(val);\r\n            updateDataSubject({ loading: true, errors: null });\r\n            for (const [key, entry] of map) {\r\n                try {\r\n                    if (entry && entry.source) {\r\n                        const { source, modifiers } = entry;\r\n                        const result = await source(mapToObject(map), ctxValue);\r\n                        const modified = applyModifiers(modifiers, ctxValue, result);\r\n                        map.set(key, modified);\r\n                    }\r\n                    if (typeof entry === 'function') {\r\n                        const result = await entry(mapToObject(map), ctxValue);\r\n                        map.set(key, result);\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    map.set(key, new Error(err));\r\n                }\r\n            }\r\n            updateDataSubject(Object.assign({ loading: false, errors: errorsFromMap(map) }, mapToObject(map)));\r\n        },\r\n        send(type, payload) {\r\n            if (mutations && Object.keys(mutations).length > 0) {\r\n                const mutation = mutations[type];\r\n                const context = ctxSubject.value;\r\n                mutation && ctxSubject.next(mutation(context, payload));\r\n            }\r\n        },\r\n        setContext(value) {\r\n            const context = ctxSubject.value;\r\n            ctxSubject.next(value instanceof Function ? value(context) : value);\r\n        },\r\n        async reset() {\r\n            ctxSubject.next(initialContext || {});\r\n            await resource.update();\r\n        },\r\n        complete() {\r\n            ctxSubject.complete();\r\n            ctxSubject.unsubscribe();\r\n            dataSubject.complete();\r\n            dataSubject.unsubscribe();\r\n        },\r\n    };\r\n    return resource;\r\n}\r\nexport function createResource(factory) {\r\n    return {\r\n        read: () => createInstance(factory),\r\n    };\r\n}\r\n","dts":{"name":"/Volumes/Projects/dev/personal/xresource/packages/xresource/index.d.ts","writeByteOrderMark":false,"text":"import { Observable } from 'rxjs';\r\nexport declare type Updater<C> = (prev: C) => C;\r\nexport declare type Mutation<C> = (ctx: C, payload: any) => C;\r\nexport declare type Mutations<C> = Record<string, Mutation<C>>;\r\nexport declare type Effect<C, D> = (resource: Resource<C, D>, ...args: any[]) => void | Promise<void>;\r\nexport declare type Effects<C, D> = Record<string, Effect<C, D>>;\r\nexport declare type PureEffects = Record<string, (...args: any[]) => void | Promise<void>>;\r\nexport declare type SourceFn<C, D, T = any> = (data: Partial<D>, ctx: C) => Promise<T>;\r\nexport declare type Modifier<C = any, T = any> = (current: T, context: C) => T;\r\nexport declare type DataItem<C = any, D = any> = {\r\n    source: SourceFn<C, D>;\r\n    modifiers?: Array<Modifier<C>>;\r\n} | SourceFn<C, D>;\r\nexport declare type DataDescriptor<C, D> = Record<string, DataItem<C, D>>;\r\nexport declare type DataResult<D> = D & {\r\n    loading: boolean;\r\n    errors: boolean;\r\n};\r\nexport interface ResourceFactory<C, D> {\r\n    context?: C;\r\n    data: DataDescriptor<C, D>;\r\n    mutations?: Mutations<C>;\r\n    effects?: Effects<C, D>;\r\n}\r\nexport interface Resource<C, D> {\r\n    effects: PureEffects;\r\n    context$: Observable<C>;\r\n    data$: Observable<DataResult<D>>;\r\n    getContext(): C;\r\n    getData(): DataResult<D>;\r\n    update(): Promise<void>;\r\n    send(type: string, payload?: any): void;\r\n    setContext(next: Updater<C> | C): void;\r\n    reset(): Promise<void>;\r\n    complete(): void;\r\n}\r\nexport interface ResourceInstance<C, D> {\r\n    read: () => Resource<C, D>;\r\n}\r\nexport declare type DefaultContext = Record<string, any>;\r\nexport declare type DefaultData = Record<string, any>;\r\nexport declare function createResource<C = DefaultContext, D = DefaultData>(factory: ResourceFactory<C, D>): ResourceInstance<C, D>;\r\n"}}
